# InnoDB记录结构

记录是向表中插入数据的单位，记录在磁盘上存放形式称为行格式或者记录格式。

行格式有四种类型：`COMPACT`、`REDUNDANT`、`DYNAMIC`、`COMPRESSED`。

------

## 指定行格式语法

在创建或修改表的语句中指定行格式：

```sql
CREATE TABLE 表名 (
    列的信息
) ROW_FORMAT=行格式名称

ALTER TABLE 表名 ROW_FORMAT=行格式名称
```

------

## COMPACT行格式

![image-20210923103418094](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210923103418094.png)

一条完整的记录分为：记录的**额外信息**与**记录的真实数据**。

### 记录的额外信息

记录的额外信息：包括，变长字段长度列表、NULL值列表和记录头信息。是服务器为了描述这条记录而不得不额外添加的一些信息。

-  **变长字段长度列表**

变成字段：把存储 `VARCHAR(M)` 这种不固定字节数据的列称为变长字段。变长字段占用的存储空间包括：真正的数据内容与占用的字节数。

在Compact 行格式中，所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序**逆序存放**，注意是逆序。

- **NULL值列表**

表中的某些列可能存储NULL 值，Compact 行格式把这些值为NULL 的列统一管理起来，存储到NULL 值列表中。当然，如果表中没有允许存储 NULL 的列，则NULL值列表也将不存在。

对一条记录里NULL值的处理过程：

**a.** 统计表中允许存储NULL 的列有哪些。主键列、被NOT NULL修饰的列都是不可以存储NULL 值的。

**b.** 将每个允许存储NULL 的列对应一个二进制位，二进制位按照列的顺序**逆序排列**。二进制位表示的意义：二进制位的值为1 时，代表该列的值为NULL ；为0 时，代表该列的值不为NULL 。

**c.**  MySQL 规定NULL值列表必须用**整数个字节的位**表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0 。

- **记录头信息**

记录头信息由固定的5 个字节组成。5 个字节也就是40 个二进制位，不同的位代表不同的意思，如图：

![image-20210923125231435](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210923125231435.png)

各二进制位的含义：

|     名称     | 大小（位） |                             描述                             |
| :----------: | :--------: | :----------------------------------------------------------: |
|   预留位1    |     1      |                           没有使用                           |
|   预留位2    |     1      |                           没有使用                           |
| delete_flag  |     1      |                     标记该记录是否被删除                     |
| min_rec_flag |     1      |        B+树的每层非叶子节点中的最小记录都会添加该标记        |
|   n_owned    |     4      |                   表示当前记录拥有的记录数                   |
|   heap_no    |     13     |                表示当前记录在记录堆的位置信息                |
| record_type  |     3      | 表示当前记录的类型， 0 表示普通记录， 1 表示B+树非叶子节点记录， 2 表示最小记录， 3表示最大记录 |
| next_record  |     16     |                   表示下一条记录的相对位置                   |

### 记录的真实数据

记录的真实数据除了自己定义的列的数据以外， MySQL 会为每个记录默认的添加一些列（也称为**隐藏列**）。

- 隐藏列

|      列名      | 是否必须 | 占用空间 |          描述          |
| :------------: | :------: | :------: | :--------------------: |
|     row_id     |    否    |  6字节   | 行ID，唯一标识一条记录 |
| transaction_id |    是    |  6字节   |         事务ID         |
|  roll_pointer  |    是    |  7字节   |        回滚指针        |

实际上这几个列的真正名称其实是：`DB_ROW_ID`、`DB_TRX_ID`、`DB_ROLL_PTR`，为了美观才写成了`row_id`、`transaction_id`和`roll_pointer`。

从上表中可以看出：InnoDB存储引擎会为每条记录都添加 transaction_id和 roll_pointer 这两个列，但是 row_id 是可选的（在没有自定义主键以及`Unique`键的情况下才会添加该列）。

- **InnoDB 表对主键的生成策略**

优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个`Unique` 键作为主键，如果表中连`Unique` 键都没有定义的话，则InnoDB 会为表默认添加一个名为`row_id` 的隐藏列作为主键。

------

### 记录格式举例

> 创建一个表，指定字符集为ascii，指定行格式为COMPACT：
>
> ```sql
> CREATE TABLE record_format_demo (
>     c1 VARCHAR(10),
>     c2 VARCHAR(10) NOT NULL,
>     c3 CHAR(10), -- 注意c3不是变长字段
>     c4 VARCHAR(10)
> ) CHARSET=ascii ROW_FORMAT=COMPACT;
> ```
>
> 记住，我们采用的是ascii字符集，后面讲的都是针对这个字符集！！ascii字符集中表示一个字符最多需要使用1个字节数。
>
> **—— 变长字段列表**：
>
> 插入两条数据：
>
> ```sql
> INSERT INTO record_format_demo(c1, c2, c3, c4) VALUES('aaaa', 'bbb', 'cc', 'd'),('eeee', 'fff', NULL, NULL);
> ```
>
> 第一条记录各**变长字段**内容的长度：
>
> ![image-20210923105457557](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210923105457557.png)
>
> 变长字段长度列表的字节串用十六进制表示的效果就是：04 03 01 。这些长度值需要按照列的逆序存放，第一条记录存储里：
>
> ![image-20210923105922722](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210923105922722.png)
>
> **—— Null值列表**：
>
> 上面创建的表record_format_demo中，只有3个值允许为NULL 的列（c1、c3、c4），对应3个二进制位，不足一个字节，所以在字节的高位补0。对于第一条记录，都不为NULL，所以对应二进制为1：
>
> ![image-20210923114802419](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210923114802419.png)
>
> 所以第一条记录的NULL值列表用十六进制表示就是： **0x00** 。而第二条记录，c3、c4为NULL，对应二进制位为1：
>
> ![image-20210923115637115](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210923115637115.png)
>
> 所以第二条记录的NULL值列表用十六进制表示就是： **0x06** 。
>
> 当然，如果一个表中有9个允许为NULL ，那这个记录的NULL 值列表部分就需要2个字节来表示了。
>
> 所以这两条记录在填充了NULL值列表后的示意图就是这样：
>
> ![image-20210923115800937](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210923115800937.png)
>
> **—— 确定使用1个字节还是2个字节表示真正字符串占用的字节数的规则**：
>
> 由于第一行记录中c1 、c2 、c4 列中的字符串都比较短，也就是说内容占用的字节数比较小，用1个字节就可以表示，但是如果变长列的内容占用的字节数比较多，可能就需要用2个字节来表示。确定字节数，需先明白这几个概念：
>
> - W：某个字符集中**表示一个字符**最多需要使用的**字节数**。如：utf8 字符集为3 、 gbk 字符集为2 、**ascii 字符集为1**。
> - M：对于变长类型VARCHAR(M)，M表示这种类型最多能存储的**字符**个数。
> - L：实际存储的字符串占用的字节数。
>
> 确定使用1个字节还是2个字节表示真正字符串占用的字节数的规则就是这样：
>
> 如果可变字段允许存储的最大字节数（ M x N ）超过255字节并且真实存储的字节数（ L）超过127字节，则使用2个字节，否则使用1个字节。
>
> 需要注意，变长字段长度列表中只存储值为 非NULL 的列内容占用的长度，值为 NULL 的列的长度是不储存的。如果表中所有的列都不是变长的数据类型的话，变长字段长度列表就没有了。
>
> **—— 加上记录的真实数据的两个记录**：
>
> ![image-20210923130545761](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210923130545761.png)
>
> 看这个图的时候需要注意几点：
>
> - 表record_format_demo 使用的是ascii 字符集，所以0x61616161 就表示字符串'aaaa' ， 0x626262 就表示字符串'bbb' ，以此类推。
> - 注意第1条记录中c3 列的值，它是CHAR(10) 类型的，它实际存储的字符串是： 'cc' ，而ascii 字符集中的字节表示是'0x6363' ，虽然表示这个字符串只占用了2个字节，但整个c3 列仍然占用了10个字节的空间，除真实数据以外的8个字节的统统都用空格字符填充，空格字符在ascii 字符集的表示就是0x20 。
> - 注意第2条记录中c3 和c4 列的值都为NULL ，它们被存储在了前边的NULL值列表处，在记录的真实数据处就不再冗余存储，从而节省存储空间。

------

## REDUNDANT行格式

Redundant 行格式是MySQL5.0 之前用的一种行格式。

![image-20210923133150917](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210923133150917.png)

### 与CPMPACT对比

- 字段长度偏移列表

Compact 行格式的开头是**变长字段长度列表**，而Redundant 行格式的开头是**字段长度偏移列表**。

没有了变长两个字，意味着Redundant 行格式会把该条记录中所有列（包括隐藏列）的长度信息都按照逆序存储到字段长度偏移列表。偏移：用两个相邻数值的差值来计算各个列值的长度。

- 记录头信息

Redundant 行格式的记录头信息占用6 字节， 48 个二进制位：

|      名称       | 大小（位） |                             描述                             |
| :-------------: | :--------: | :----------------------------------------------------------: |
|     预留位1     |     1      |                           没有使用                           |
|     预留位2     |     1      |                           没有使用                           |
|   delete_flag   |     1      |                     标记该记录是否被删除                     |
|  min_rec_flag   |     1      |        B+树的每层非叶子节点中的最小记录都会添加该标记        |
|     n_owned     |     4      |                   表示当前记录拥有的记录数                   |
|     heap_no     |     13     |                表示当前记录在记录堆的位置信息                |
|     n_field     |     10     |                      表示记录中列的数量                      |
| 1byte_offs_flag |     1      | 标记字段长度偏移列表中每个列对应的偏移量是使用1字节还是2字节表示 |
|   next_record   |     16     |                   使用1字节还是2字节表示的                   |

与Compact 行格式的记录头信息对比来看，有两处不同：

1. Redundant 行格式多了n_field 和1byte_offs_flag 这两个属性。

2. Redundant 行格式没有record_type 这个属性。

- NULL 值的处理

Redundant 行格式并没有NULL值列表，取而代之的是，在字段长度偏移列表中的各个列对应的**偏移量**处做了一些特殊处理 —— 将列对应的偏移量值的第一个比特位作为是否为NULL 的依据，该比特位也可以被称之为`NULL`比特位。

- 记录变为Redundant格式

![image-20210923133307333](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210923133307333.png)

------

------

# InnoDB数据页结构

## 磁盘存储与页的简述

**磁盘存储**：

- 系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么

- InnoDB 存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位，InnoDB 存储引擎中默认每个页的大小为 16KB
- InnoDB 引擎将若干个地址连接磁盘块，以此来达到页的大小 16KB，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘 I/O 次数，提高查询效率

**页是InnoDB 管理存储空间的基本单位**，一个页的大小一般是16KB 。为了不同的目的设计了不同的页，比如：存放表空间头部信息的页，存放Insert Buffer信息的页，存放undo 日志信息的页等等。**存放表中记录**类型的页叫做索引（ INDEX ）页。索引是一种为了提高查询速度而设计的数据结构，表中的记录就是数据，所以索引页也叫做数据页。

## 数据页的结构

数据页代表的16KB 大小的存储空间可以被划分为多个部分，不同部分有不同的功能。

![image-20210924102437897](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210924102437897.png)

一个InnoDB 数据页的存储空间大致被划分成了7 个部分，7个部分都存储的内容：

|        名称        |     中文名     | 占用空间(字节) |         简单描述         |
| :----------------: | :------------: | :------------: | :----------------------: |
|    File Header     |     文件头     |       38       |       页的通用信息       |
|    Page Header     |     页面头     |       56       |     数据页专有的信息     |
| Infimum + Supremum | 最大、最小记录 |       26       |     两个虚拟的行记录     |
|    User Records    |    用户记录    |     不确定     |   实际存储的行记录内容   |
|     Free Space     |    空闲空间    |     不确定     |    页中尚未使用的空间    |
|   Page Directory   |    页面目录    |     不确定     | 页中的某些记录的相对位置 |
|    File Trailer    |     文件尾     |       8        |      校验页是否完整      |

------

### User Records + Free Space

用户存储的记录会按照指定的**行格式**存储到User Records 部分。最开始生成页的时候，并没有User Records部分，每插入一条记录，都会从Free Space部分申请一个记录大小的空间划分到User Records部分。当Free Space部分的全部空间被User Records部分替代之后，再插入新的记录就需要申请新的页。

#### 记录头信息详解

![image-20210924104117574](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210924104117574.png)

Compact行格式，记录头信息的各个属性的含义：

|     名称     | 大小（位） |                             描述                             |
| :----------: | :--------: | :----------------------------------------------------------: |
|   预留位1    |     1      |                           没有使用                           |
|   预留位2    |     1      |                           没有使用                           |
| delete_flag  |     1      |                     标记该记录是否被删除                     |
| min_rec_flag |     1      |        B+树的每层非叶子节点中的最小记录都会添加该标记        |
|   n_owned    |     4      |    记录分组之后，每组第一条记录的该值表示本组所有的记录数    |
|   heap_no    |     13     |                表示当前记录在记录堆的位置信息                |
| record_type  |     3      | 表示当前记录的类型， 0 表示普通记录， 1 表示B+树非叶子节点记录， 2 表示最小记录， 3表示最大记录 |
| next_record  |     16     |                   表示下一条记录的相对位置                   |

- delete_mask

标记着当前记录是否被删除，占用1个二进制位，值为 0 代表记录并没有被删除，为 1 代表记录被删除掉。

被删除的记录不立即从磁盘上移除，还在在磁盘里，只是打一个删除标记而已。所有被删除掉的记录都会组成一个所谓的**垃圾链表**，在这个链表中的记录占用的空间称之为所谓的**可重用空间**，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。

将这个delete_mask位设置为1和将被删除的记录加入到垃圾链表中其实是两个阶段。

- min_rec_mask

B+树的每层非叶子节点中的最小记录都会添加该标记。

- n_owned

代表每个分组里，所拥有的记录的数量，一般是分组里主键最大值才有的。

- heap_no

在数据页的User Records中插入的记录是一条一条紧凑的排列的，这种紧凑排列的结构又被称为**堆**。

为了便于管理这个堆，把记录在堆中的相对位置给定一个编号——**heap_no**。所以heap_no这个属性表示当前记录在本页中的位置。

用户插入记录的heap_no从2开始，其中heap_no为0和1的记录，分别称为：最小记录 **Infimum**，最大记录 **Supremum**。这两个记录是MySQL自动插入的，也称为伪记录或者虚拟记录。

- record_type

这个属性表示当前记录的类型，一共有4种类型的记录， 0 表示普通用户记录， 1 表示B+树非叶节点记录， 2 表示最小记录， 3 表示最大记录。

- next_record

表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量，可以理解为指向下一条记录地址的指针。下一条记录指得并不是按照插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。

> 举例：
>
> ![image-20210924112935525](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210924112935525.png)
>
> 删除一条记录：
>
> ![image-20210924113306816](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210924113306816.png)
>
> 从图中可以看出来，删除第2条记录前后主要发生的变化：
>
> - 被删记录没有从存储空间中移除，而是把该记录的delete_mask 设置为1 ，next_record 变为0；
> - 被删记录的前一条记录的next_record 指向后一条记录：第1条记录的next_record 指向了第3条记录；
> - 最大记录的n_owned 值减1。

页中的记录通过记录头信息中的`next_record`属性以单链表的形式存在，链表中的各个节点是按照主键值由小到大的顺序连接起来的。并规定 Infimum记录 的下一条记录就是本页中主键值最小的**用户记录**，而本页中主键值最大的**用户记录**的下一条记录就是 Supremum记录。

---

### Page Directory

查找一条记录，可以采用遍历链表的方式，从Infimum 记录（最小记录）开始往后找，但这种方法效率太低。

#### 页目录

为了解决直接遍历查询缓慢的问题，设计了类似于课本目录的页目录：

- 记录分组：将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。
- 组内最大记录的n_owned 属性记录记录条数：每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned 属性表示该记录拥有多少条记录，也就是该组内共有几条记录。
- 根据最大最小记录的地址偏移量构造页目录：**将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方，这个地方就是所谓的Page Directory ，也就是页目录**。页面目录中的这些地址偏移量被称为**槽**（英文名： Slot ），所以这个页面目录就是由槽组的。

> 举例：
>
> ![image-20210925164241686](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210925164241686.png)
>
> 从上图来看，需要注意：
>
> 页目录里面有两个槽，说明分为了两个组，分别是最小记录为一组，四条用户记录与最大记录为一组。所以最小记录的 n_owned 属性为1，最大记录的 n_owned 属性为5。
>
> 为了更加直观，画为这样子：
>
> ![image-20210925164903047](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210925164903047.png)
>
> 记录变多后：
>
> ![image-20210925165759227](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210925165759227.png)

#### 分组规则

对于分组规定的规则：

- 对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1~8 条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间。
- 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。
- 之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽中对应的最大记录的 n_owned 值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。
- 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。

#### 页目录查找记录

当需要在一个数据页中查找指定主键值的记录的过程分为两步：

- 通过**二分法**确定该记录所在的槽，并找到该槽中主键值最小的那条记录。
- 通过记录的 next_record 属性遍历该槽所在的组中的各个记录。

### Page Header

页面头部：占用固定的56 个字节，存储着数据页中记录的状态信息。比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等。

|         名称         | 占用空间（字节） |                             描述                             |
| :------------------: | :--------------: | :----------------------------------------------------------: |
|   PAGE_N_DIR_SLOTS   |        2         |                      在页目录中的槽数量                      |
|    PAGE_HEAP_TOP     |        2         | 还未使用的空间最小地址，也就是说从该地址之后就是 Free Space  |
|   PAGE_BTR_SEG_TOP   |        10        | 本页中的记录的数量（包括最小和最大记录以及标记为删除的记录） |
|     PAGE_N_HEAP      |        2         | 第一个已经标记为删除的记录地址（各个已删除的记录通过next_record 也会组成一个单链表，单链表中的记录可以被重新利用） |
|      PAGE_FREE       |        2         |                    已删除记录占用的字节数                    |
|     PAGE_GARBAGE     |        2         |                      最后插入记录的位置                      |
|   PAGE_LAST_INSERT   |        2         |                        记录插入的方向                        |
|  **PAGE_DIRECTION**  |        2         |                  一个方向连续插入的记录数量                  |
| **PAGE_N_DIRECTION** |        2         | 该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录） |
|     PAGE_N_RECS      |        2         |        修改当前页的最大事务ID，该值仅在二级索引中定义        |
|   PAGE_MAX_TRX_ID    |        8         |                   当前页在B+树中所处的层级                   |
|      PAGE_LEVEL      |        2         |               索引 ID，表示当前页属于哪个索引                |
|    PAGE_INDEX_ID     |        8         |          B+树叶子段的头部信息，仅在B+树的Root页定义          |
|  PAGE_BTR_SEG_LEAF   |        10        |         B+树非叶子段的头部信息，仅在B+树的Root页定义         |

- PAGE_DIRECTION

PAGE_DIRECTION：表示最后一条记录插入方向的状态 。假如新插入的一条记录的主键值比上一条记录的主键值大，就说这条记录的插入方向是右边，反之则是左边。

- PAGE_N_DIRECTION

PAGE_N_DIRECTION：表示连续N次插入新记录的方向都是一致的。当然，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。

------

### File Header

文件头部：占用固定的38字节，描述了一些通用于各种页面的信息，比如：页号，上一个页，下一个页是什么等。

文件头部包括这些字段：

|               名称               | 占用空间（字节） |                             描述                             |
| :------------------------------: | :--------------: | :----------------------------------------------------------: |
|   **FIL_PAGE_SPACE_OR_CHKSUM**   |        4         |                   页的校验和（checksum值）                   |
|       **FIL_PAGE_OFFSET**        |        4         |                             页号                             |
|        **FIL_PAGE_PREV**         |        4         |                        上一个页的页号                        |
|        **FIL_PAGE_NEXT**         |        4         |                        下一个页的页号                        |
|           FIL_PAGE_LSN           |        8         | 页面被最后修改时对应的日志序列位置（英文名是：Log SequenceNumber） |
|          FIL_PAGE_TYPE           |        2         |                          该页的类型                          |
|     FIL_PAGE_FILE_FLUSH_LSN      |        8         | 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值 |
| FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID |        4         |                       页属于哪个表空间                       |

- FIL_PAGE_SPACE_OR_CHKSUM

FIL_PAGE_SPACE_OR_CHKSUM：个代表当前页面的校验和（checksum）。

校验和：通过某种算法来计算一个比较短的值来代表一个很长的字节串，这个比较短的值就称为校验和。这样在比较两个很长的字节串之前先比较这两个长字节串的校验和，如果校验和都不一样两个长字节串肯定是不同的，所以省去了直接比较两个比较长的字节串的时间损耗。

- FIL_PAGE_OFFSET

每一个页都有一个单独的页号，InnoDB 通过页号来可以唯一定位一个页。

- FIL_PAGE_TYPE

InnoDB 为了不同的目的而把页分为不同的类型，比如：索引页、日志页和溢出页等。

- FIL_PAGE_PREV 和FIL_PAGE_NEXT

InnoDB以页为单位存放数据的， FIL_PAGE_PREV 和FIL_PAGE_NEXT代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，而无需这些页在物理上真正连着。

需要注意的是，并不是所有类型的页都有上一个和下一个页的属性。数据（索引）页才有这两个属性。

> 举例：
>
> ![image-20210925172841385](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210925172841385.png)

---

### File Trailer

InnoDB 存储引擎会把数据存储到磁盘上，但是磁盘速度太慢，需要以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但有可能在同步了一半的时候中断，比如：断电。所以设计了文件尾部。

文件尾部：由8个字节组成，检测一个页是否完整，是所有类型页面的通用部分。

- 前4个字节代表页的校验和

这部分和 File Header 中的校验和相对应。

每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header 在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在File Header 中的校验和就代表着已经修改过的页，而在File Trialer 中的校验和代表着原先的页，二者不同则意味着同步中间出了错。

- 后4个字节代表页面被最后修改时对应的日志序列位置（LSN）

这个部分也是为了校验页的完整性的。

---

---

# InnoDB表空间

表空间是一个抽象的概念，对于系统表空间来说，对应着文件系统中一个或多个实际文件；对于每个独立表空间来说，对应着文件系统中一个名为表名.ibd 的实际文件。

可以把表空间想象成被切分为许多个页的池子，当想为某个表插入一条记录的时候，就从池子中捞出一个对应的页来把数据写进去。

![在这里插入图片描述](https://img-blog.csdnimg.cn/00b5116842dc45bca827b5804136674a.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1h1ZXlpbkd1bw==,size_16,color_FFFFFF,t_70)

------

## 数据页通用结构

InnoDB是以页为单位管理存储空间的。前面学习过的B+数索引的页类型类型为索引页（也叫数据页），聚簇索引（也就是完整的表数据）和二级索引都是以B+树的形式保存到表空间的。页的通用结构为：

![image-20211009141911309](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211009141911309.png)

- File Header文件头：记录页面的一些通用信息。包括：

|               名称               | 占用空间（字节） |                             描述                             |
| :------------------------------: | :--------------: | :----------------------------------------------------------: |
|     FIL_PAGE_SPACE_OR_CHKSUM     |        4         |                   页的校验和（checksum值）                   |
|         FIL_PAGE_OFFSET          |        4         |                             页号                             |
|          FIL_PAGE_PREV           |        4         |                        上一个页的页号                        |
|          FIL_PAGE_NEXT           |        4         |                        下一个页的页号                        |
|           FIL_PAGE_LSN           |        8         | 页面被最后修改时对应的日志序列位置（英文名是：Log SequenceNumber） |
|        **FIL_PAGE_TYPE**         |        2         |                          该页的类型                          |
|     FIL_PAGE_FILE_FLUSH_LSN      |        8         | 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值 |
| FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID |        4         |                       页属于哪个表空间                       |

`FIL_PAGE_TYPE`属性表示页的类型，包括：

|        类型名称         | 16进制 |          描述           |
| :---------------------: | :----: | :---------------------: |
| FIL_PAGE_TYPE_ALLOCATED | 0X0000 |   最新分配，还未使用    |
|    FIL_PAGE_UNDO_LOG    | 0X0002 |       undo日志页        |
|     FIL_PAGE_INODE      | 0X0003 |      存储段的信息       |
| FIL_PAGE_IBUF_FREE_LIST | 0X0004 |  Change Buffer空闲列表  |
|  FIL_PAGE_IBUF_BITMAP   | 0X0005 | Change Buffer的一些属性 |
|    FIL_PAGE_TYPE_SYS    | 0X0006 |    存储一些系统数据     |
|  FIL_PAGE_TYPE_TRX_SYS  | 0X0007 |      事务系统数据       |
|  FIL_PAGE_TYPE_FSP_HDR  | 0X0008 |     表空间头部信息      |
|   FIL_PAGE_TYPE_XDES    | 0X0009 |    存储区的一些属性     |
|   FIL_PAGE_TYPE_BLOG    | 0X000A |         溢出页          |
|     FIL_PAGE_INDEX      | 0X45BF |  索引页，也称为数据页   |

- File Trailer 文件尾：校验页是否完整，保证从内存到磁盘刷新时内容的一致性。

------

## 独立表空间

InnoDB 支持许多种类型的表空间，这里重点关注独立表空间和系统表空间的结构。

### 区的概念

表空间被划分为许多连续的区，**每个区默认由64个页组成**，一个区默认占用1MB空间大小。**每256个区划分为一组**，每个组的最开始的几个页面类型是固定的。

![image-20211009144908056](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211009144908056.png)



上图中，一个颜色代表一个组。每个组中有些页面类型固定：

- 第一个组最开始的3个页面的类型是固定的。每个属性表示含义：
  - FSP_HDR 类型：这个类型的页面是用来登记整个表空间的一些整体属性以及本组所有的区的属性。需要注意的一点是，**整个表空间只有一个FSP_HDR 类型的页面**。
  - IBUF_BITMAP 类型：这个类型的页面是存储本组所有的区的所有页面关于INSERT BUFFER的信息。
  - INODE 类型：存储了许多NODE的数据结构，用来记录段中的属性。
- 其余各组最开始的2个页面的类型是固定的，分别是：
  - XDES 类型：全称是extent descriptor ，用来登记本组256个区的属性。XDES 类型的页面和FSP_HDR 类型的页面作用类似，只不过FSP_HDR 类型的页面还会额外存储一些表空间的属性。
  - IBUF_BITMAP 类型：与第一组中的一样。

区的提出是想解决，索引页（也就是数据页）双向链表相邻的两个页物理距离可能比较远，这样就导致去磁盘加载页面的时候需要重新定位磁头，导致随机I/O，如果尽量的让页面距离更近，就会把随机IO换成顺序IO，从而提高查询速度。

------

### 段的概念

#### 引入段的原因

有了区的概念之后还没结束，因为不把叶子节点和非叶子节点区分开来扫描结果还是不太理想的。

比如，B+树形成的过程，插入记录不断有新的页面（叶子节点）产生，同时也产生了很多索引页面（非叶子节点），如果把这些页面统统放到一个区里，那么存放数据的叶子节点间还是存在物理距离。所以有了段的概念。

叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点或者非叶子节点的区的集合就算是一个段（ segment ）。也就是说**一个索引会生成2个段，一个叶子节点段，一个非叶子节点段**。

#### 段的概念

段：是一个逻辑上的概念，不对应表空间中某一个连续的物理区域，由若干个零散的页面以及一些完整的区组成。

段是以区为单位申请存储空间的，但一个区被整个分配给某一个段，对于数据量较小的表来说太浪费存储空间。而且分配后的区，即使段的数据填不满区中所有的页面，那余下的页面也不能被其他段使用。为了避免这种情况，提出了**碎片区**（fragment）的概念。

在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是**碎片区中的页可以用于不同的目的**，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。

引入碎片区后，为某段分配存储空间的策略：

- 刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。
- 当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间。

------

### 区的详解

#### 区的状态

|  状态名   |                  含义                  |
| :-------: | :------------------------------------: |
|   FREE    | 空闲的区，没有任何页面被用到（表空间） |
| FREE_FRAG |      有剩余空间的碎片区（表空间）      |
| FULL_FRAG |     没有剩余空间的碎片区（表空间）     |
|   FSEG    |            附属于某个段的区            |

注意，处于FREE 、FREE_FRAG 以及FULL_FRAG 这三种状态的区都是独立的，算是直属于**表空间**；而处于FSEG 状态的区是附属于**某个段**的。

#### 区的管理：XDES Entry 结构

XDES Entry（Extent Descriptor Entry）结构，用于管理区。每一个区都对应着一个XDES Entry 结构，这个结构记录了对应的区的一些属性。

![image-20211009155607083](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211009155607083.png)

- Segment ID （8字节）：表示就是该区所在的段。每一个段都有一个唯一的编号。

- List Node （12字节）：用于将若干个区的XDES Entry结构串联成一个链表。结构如下：

  ![image-20211009155815462](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211009155815462.png)

可以看出，如果想定位表空间内的某一个位置的话，只需指定页号以及该位置在指定页号中的页内偏移量即可。

- State （4字节）：表明区的状态。分别是： FREE 、FREE_FRAG 、FULL_FRAG和FSEG 。
- Page State Bitmap （16字节）：16个字节，128个比特位。一个区默认有64个页，这128个比特位被划分为64个部分，每个部分2个比特位，每两个比特位对应区中的一个页每（按顺序），第一位表示页面是否空闲，第二位没使用。

#### XDES Entry链表

##### 链表的引入

向某个段中插入数据时，申请新页面的过程：

- 当段中数据量较少的时候，首先会查看表空间中是否有空闲页面的**碎片区**：
  - 如果有，那么从该区中取一些零散的页把数据插进去；
  - 否则到表空间下申请一个**空闲区**，把该区的状态变为有**空闲页面的碎片区** ，然后从该新申请的区中取一些零碎的页把数据插进去。之后**不同的段**使用零碎页的时候都会从该区中取，直到该区中没有空闲空间，然后该区就变成了没有剩余空间的碎片区 。

- 依次重复步骤1，当段中的数据已经占满32个零碎的页后，就申请完整的区来插入数据。

判断直属于表空间中区的状态：

通过XDES Entry中的**List Node指针**来完成。把每种状态的区对应的XDES Entry结构通过List Node连接成一个链表，分别称之为：**FREE链表**、**FREE_FRAG 链表**、**FULL_FRAG 链表**。

判断附属于某个段的区：

因为**不同的段不能共用一个区**，所以想要每个段都有不同的链表，可以根据段号（也就是**Segment ID** ）来建立链表。

- **FREE 链表**：同一个段中，所有页面都是空闲的区加入到这个链表。注意和直属于表空间的FREE 链表区别开了，此处的FREE链表是附属于某个段的。
- **NOT_FULL 链表**：同一个段中，仍有空闲空间的区加入到这个链表。
- **FULL 链表**：同一个段中，已经没有空闲空间的区被加入到这个链表。

再次强调，每一个索引都对应两个段，每个段都会维护上述的3个链表。

##### List Base Node(链表基节点)

前面介绍了许多链表，如何找到这些链表的头节点或者尾节点才是该了解的。为了定位头节点或尾节点，设计了一个名为List Base Node(链表基节点)的结构。

![image-20211010115453858](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211010115453858.png)

这个结构中包含了链表的头节点和尾节点的指针以及这个链表中包含了多少节点的信息。前面介绍的每一个链表都对应一个List Base Node结构。其中：

- List Length 表明该链表一共有多少节点；
- First Node Page Number 和First Node Offset 表明该链表的头节点在表空间中的位置；
- Last Node Page Number 和Last Node Offset 表明该链表的尾节点在表空间中的位置。

一般把某个链表对应的List Base Node 结构放置在表空间中固定的位置，这样想找定位某个链表就变得十分容易。

##### 链表小结

表空间是由若干个区组成的，每个区都对应一个XDES Entry的结构。

直属于表空间的区：对应的XDES Entry 结构可以分成FREE 、FREE_FRAG 和FULL_FRAG 这3个链表；

附属于某个段的区：每个段中的区对应的XDES Entry 结构可以分成FREE 、NOT_FULL 和FULL 这3个链表。

每个链表都对应一个List Base Node 的结构，这个结构里记录了链表的头、尾节点的位置以及该链表中包含的节点数。正是因为这些链表的存在，管理这些区才变成容易。

### 段的结构

段精准定义：32个零散的页面和一些完整的区的集合。

像每个**区**都有对应的**XDES Entry**来记录这个区中的属性一样，每个**段**都定义了一个**INODE Entry**结构来记录一下段中的属性。

![image-20211119173526907](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211119173526907.png)

- Segment ID：段的编号（ID）。
- NOT_FULL_N_USED：指的是在NOT_FULL链表中已经使用了多少个页面。
- List Base Node：分别为段的FREE 链表、NOT_FULL链表、FULL 链表定义的List Base Node 。想查找某个段的某个链表的头节点和尾节点的时候，直接到这个部分找到对应链表的List Base Node。
- Magic Number ：标记INODE Entry是否已经被初始化（初始化：就是把各个字段的值都填进去了）。如果这个数字是值的97937874 ，表明该INODE Entry 已经初始化，否则没有被初始化。
- Fragment Array Entry：表示32个零散页面的页号。

### 固定类型的页面介绍

####  FSP_HDR类型

第一个组的第一个页面，当然也是表空间的第一个页面，页号为0。这个页面的类型是FSP_HDR ，它存储了表空间的一些整体属性以及第一个组内256个区的对应的XDES Entry 结构。

![image-20211010130743860](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211010130743860.png)

从图中可以看出，一个完整的FSP_HDR 类型的页面大致由5个部分组成，各个部分的具体释义如下表：

|       名称        |    中文名    | 占用空间/字节 |           简单描述            |
| :---------------: | :----------: | :-----------: | :---------------------------: |
|    File Header    |   文件头部   |      38       |         页的通用信息          |
| File Space Header |  表空间头部  |      112      |   表空间的一些整体属性信息    |
|    XDES Entry     |  区描述信息  |     10240     | 存储本组256个区对应的属性信息 |
|    Empty Space    | 尚未使用空间 |     5986      |       用于页结构的填充        |
|   File Trailer    |   文件尾部   |       8       |        校验页是否完整         |

- File Space Header

![image-20211010131339457](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211010131339457.png)

各个属性的简单描述：

|                  名称                   | 占用空间/字节 |                             描述                             |
| :-------------------------------------: | :-----------: | :----------------------------------------------------------: |
|                Space ID                 |       4       |                          表空间的ID                          |
|                Not Used                 |       4       |                  这4个字节未被使用，可忽略                   |
|                  Size                   |       4       |                    当前表空间占有的页面数                    |
|               FREE Limit                |       4       | 尚未被初始化的最小页号，大于或等于这个页号的区对应的XDES Entry结构都没有被加入FREE链表 |
|               Space Flags               |       4       |             表空间的一些占用存储空间比较小的属性             |
|               FRAG_N_USED               |       4       |               FREE_FRAG链表中已使用的页面数量                |
|      List Base Node for FREE List       |      16       |                       FREE链表的基节点                       |
|    List Base Node for FREE_FRAG List    |      16       |                    FREE_FREG链表的基节点                     |
|    List Base Node for FULL_FRAG List    |      16       |                    FULL_FREG链表的基节点                     |
|         Next Unused Segment ID          |       8       |        当前表空间中最大段的下一个未使用的 Segment ID         |
| List Base Node for SEG_INODES_FULL List |      16       |                 SEG_INODES_FULL链表的基节点                  |
| List Base Node for SEG_INODES_FREE List |      16       |                 SEG_INODES_FREE链表的基节点                  |

- XDES Entry

XDES Entry在表空间的第一个页面中保存。一个XDES Entry 结构的大小是40字节，但是一个页面的大小有限，只能存放有限个XDES Entry 结构，所以才把256个区划分成一组，在每组的第一个页面中存放256个XDES Entry 结构。

#### XDES 类型

与FSP_HDR相似，只是少了File Space Header这个用于记录表空间的属性。（无：表示没有使用）

![image-20211010140912939](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211010140912939.png)

#### IBUF_BITMAP 类型

##### Change Buffer相关

每插入一条记录其实都是想B+树中插入记录，插入过程是先把这个记录插入到聚簇索引的页面中，然后插入到二级索引页面中。

虽然每个索引中断都是距离尽可能进的，但是这些段属于不同的索引，所以这些页面在表空间中仍然是随机分布，仍然会产生随机I/O，严重影响性能。

所以有了Change Buffer，本质上，Change Buffer也是一个B+树。

##### Change Buffer作用

当页面仍然在磁盘上时，那么该修改将先被暂存在Change Buffer中，之后服务器空闲，或者页面从磁盘载入内存中时，再将其修改合并到对应页面。

#### INODE类型

##### INODE类型结构

第一个分组的第三个页面的类型是INODE。前面知道，每个索引定义了两个段，某些特殊功能也定义了些特殊的段。为了方便管理，每个段又设计了一个INODE Entry 结构，这个结构中记录了关于这个段的相关属性。这个INODE 类型的页就是为了存储INODE Entry结构而存在的。

![image-20211010142035571](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211010142035571.png)

从图中可以看出，一个INODE 类型的页面是由这几部分构成的：

|              名称              |    中文名    | 占用空间/字节 |                    描述                    |
| :----------------------------: | :----------: | :-----------: | :----------------------------------------: |
|          File Header           |   文件头部   |      38       |              页的一些通用信息              |
| List Node for INODE  Page List | 通用链表节点 |      12       | 存储上一个INODE页面和下一个INODE页面的指针 |
|          INODE Entry           |  段描述信息  |    16，320    |           具体的INODE Entry结构            |
|          Empty Space           | 尚未使用空间 |       6       |       用于页结构的填充，没啥实际意义       |
|          File Trailer          |   文件尾部   |       8       |               校验页是否完整               |

当页面中的段超过85个，也就是INODE Entry超过85个时，一个页就存不下了。就需要使用额外的INODE类型页面存储这些结构。

##### 存储INODE Entry

- 先看看Free链表是否为空，如果不为空，则取出第一个链表节点，放入该页面。如果接入这个Entry之后页面正好满了，就把这个页面放入FULL链表。
- 如果链表为空，就需要从表空间中申请一个页面，页面类型修改为INODE类型，放入FREE链表，把Entry放入新申请的页面中。

![img](https://img-blog.csdnimg.cn/0f71a4d9cc5b4d8e993367c3f70f4865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1h1ZXlpbkd1bw==,size_16,color_FFFFFF,t_70)

### Segment Header结构

一个索引会产生两个段，分别是叶子节点段和非叶子节点段，而每个段都会对应一个INODE Entry结构，如何判断叶子结点和非叶子结点的段对应哪个INODE Entry结构？

**通过INDEX类型页中的Page Header部分来判断**。

|       名称        | 占用空间/字节 |                             描述                             |
| :---------------: | :-----------: | :----------------------------------------------------------: |
|        ...        |      ...      |                             ...                              |
| PAGE_BTR_SEG_LEAF |      10       |          B+树非叶子段的头部信息，仅在B+树的根页定义          |
| PAGE_BTR_SEG_TOP  |      10       | 本页中的记录的数量（包括最小和最大记录以及标记为删除的记录），仅在B+树的根页定义 |

PAGE_BTR_SEG_LEAF 和PAGE_BTR_SEG_TOP 都占用10个字节，它们对应一个叫Segment Header的结构，该结构图示如下：

![image-20211011100232563](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211011100232563.png)

各个部分的具体释义如下：

|              名称              | 占用空间/字节 |               描述                |
| :----------------------------: | :-----------: | :-------------------------------: |
|  Space ID of the INODE Entry   |       4       |   INODE Entry结构所在的表空间ID   |
| Page Number of the INODE Entry |       4       |   INODE Entry结构所在的页面页号   |
|  Byte Offset of the INODE Ent  |       2       | INODE Entry结构在该页面中的偏移量 |

PAGE_BTR_SEG_LEAF 记录着**叶子节点段**对应的INODE Entry 结构的地址是哪个表空间的哪个页面的哪个偏移量。

PAGE_BTR_SEG_TOP 记录着**非叶子节点段**对应的INODE Entry 结构的地址是哪个表空间的哪个页面的哪个偏移量。

------

## 系统表空间

系统表空间的结构和独立表空间基本类似，只不过由于整个MySQL进程**只有一个系统表空间**，在系统表空间中会额外记录一些有关整个系统信息的页面，所以会比独立表空间多出一些记录这些信息的页面。

系统表空间相当于是表空间之首，它的**表空间 ID （Space ID）是0** 。

### 系统表空间的整体结构

系统表空间与独立表空间的一个非常明显的不同之处就是在表空间开头有许多记录整个系统属性的页面：

![image-20211011102854419](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211011102854419.png)

可以看到，系统表空间和独立表空间的前三个页面（页号分别为0 、1 、2 ，类型分别是FSP_HDR 、IBUF_BITMAP 、INODE ）的类型是一致的，只是页号为3 ～ 7 的页面是系统表空间特有的。

| 页号 | 页面类型 |        英文描述        |            描述             |
| :--: | :------: | :--------------------: | :-------------------------: |
|  3   |   SYS    |  Insert Buffer Header  | 存储Insert Buffer的头部信息 |
|  4   |  INDEX   |   Insert Buffer Root   |  存储Insert Buffer的根页面  |
|  5   | TRX_SYS  |   Transction System    |     事务系统的相关信息      |
|  6   |   SYS    | First Rollback Segment |     第一个回滚段的页面      |
|  7   |   SYS    | Data Dictionary Header |      数据字典头部信息       |

除了这几个记录系统属性的页面之外，系统表空间的extent 1 和extent 2 这两个区，也就是页号从64 ~ 191这128个页面被称为Doublewrite buffer ，也就是双写缓冲区。

### InnoDB数据字典

平时使用INSERT 语句向表中插入的那些记录称之为用户数据，MySQL只是作为一个软件来为我们保管这些数据，提供方便的增删改查接口。MySQL除了保存着插入的用户数据之外，还需要保存许多额外的信息，比如：某个表属于哪个表空间，表里边有多少列等信息。

这些信息不属于用户记录信息，是为了更好的管理这些用户数据而不得已引入的一些额外数据，这些数据也称为**元数据**。InnoDB存储引擎特意定义了一些列的**内部系统表**（internal system table）**来记录这些这些元数据**。

这些内部系统表也被称为**数据字典**，它们都是以B+ 树的形式保存在系统表空间的某些页面中，其中
SYS_TABLES 、SYS_COLUMNS 、SYS_INDEXES 、SYS_FIELDS 这四个表尤其重要，称之为**基本系统表**（basic
system tables）。

这4个基本系统表是表中之表，这4个表的元数据（就是它们有哪些列、哪些索引等信息）只能**硬编码到代码中**。然后，用一个固定的页面来记录这4个表的聚簇索引和二级索引对应的B+树位置，这个页面就是**页号为7** 的页面，类型为SYS ，记录了Data Dictionary Header （也就是**数据字典的头部信息**）。

页7的结构：

![image-20211011111950860](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211011111950860.png)

这个页包括：

|          名称          |      中文名      | 占用空间/字节 |                             描述                             |
| :--------------------: | :--------------: | :-----------: | :----------------------------------------------------------: |
|      File Header       |     文件头部     |      38       |                       页的一些通用信息                       |
| Data Dictionary Header | 数据字典头部信息 |      56       | 记录一些基本系统表的根页面位置以及InnoDB存储引擎的一些全局信息 |
|     Segment Header     |    段头部信息    |      10       |          记录本页面所在段对应的INODE Entry位置信息           |
|      Empty Space       |   尚未使用空间   |     16272     |                用于页结构的填充，没啥实际意义                |
|      File Trailer      |     文件尾部     |       8       |                        校验页是否完整                        |

可以看到这个页面里有Segment Header 部分，意味着这些**有关数据字典的信息当成一个段来分配存储空间**，称之为**数据字典段**吧

### information_schema系统数据库

需要注意一点的是，用户是不能直接访问InnoDB 的这些内部系统表的，除非你直接去解析系统表空间对应文件系统上的文件。但在系统数据库information_schema 中提供了一些以innodb_sys 开头的表，用来查看这些内部表的内容：

```sql
SHOW TABLES LIKE 'innodb_sys%';
```

在information_schema 数据库中的这些以INNODB_SYS 开头的表并不是真正的内部系统表（内部系统表就是上边唠叨的以SYS 开头的那些表），而是在存储引擎启动时读取这些以SYS 开头的系统表，然后填充到这些以INNODB_SYS 开头的表中。

![image-20211011113439709](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211011113441445.png)

参考：

[MySQL表空间详解_XueyinGuo的博客-CSDN博客](https://blog.csdn.net/XueyinGuo/article/details/119223154#comments_18341083)

[InnoDB表空间_gfu_的博客-CSDN博客](https://blog.csdn.net/qq_43352723/article/details/120700328?spm=1001.2014.3001.5501)

------

------

# 数据目录（data）

![](E:\A_java\图像git\未命名文件.png)

## 数据目录介绍

数据库与文件系统：InnoDB 、MyISAM 存储引擎把表存储在**磁盘**上，而操作系统使用**文件系统**来管理磁盘。所以，可以说 InnoDB 、 MyISAM 这样的存储引擎是把数据存储在文件系统上的。

数据目录概念：数据目录在MySQL服务器程序启动时提供一些文件，并存储MySQL在运行过程中产生的数据。

确定MySQL中数据目录的路径：

```sql
SHOW VARIABLES LIKE 'datadir';
```

## 数据目录结构

### 数据库在文件系统中的表示

每个数据库都对应**数据目录**下的一个子目录，或者说对应一个文件夹。

当使用`CREATE DATABASE`创建一个数据库的时候，MySQL会做两件事：

- 在数据目录下创建一个和数据库名同名的子目录（或者说是文件夹）；
- 在该与数据库名同名的子目录下创建一个名为`db.opt` 的文件，这个文件包含了该数据库的各种属性，比如：该数据库的字符集和比较规则。

MySQL自带系统数据库有：

- information_schema

这个数据库保存着MySQL服务器维护的所有其他数据库的信息，比如有哪些表、哪些视图、哪些触发器、哪些列、哪些索引等。这些信息并不是真实的用户数据，而是一些**描述性信息**，有时候也称之为**元数据**。

- mysql

这个数据库非常重要，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。

- performance_schema

这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，算是对MySQL服务器的一个性能监控。包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等等信息。

- sys

这个数据库主要是通过视图的形式把information_schema 和performance_schema 结合起来，让程序员可以更方便的了解MySQL服务器的一些性能信息。

除了information_schema 这个系统数据库外，其他的数据库在数据目录下都有对应的子目录。

### 表在文件系统中的表示

数据都是以记录的形式插入到表中的，表信息分为两种：

- 表结构的定义
- 表中的数据

表结构：包括表名称、表中的列数、每列的数据类型、约束条件、索引以及使用的字符集和比较规则等信息。为了保存这些信息，InnoDB 和MyISAM 两种存储引擎都在数据目录下对应的数据库子目录下创建描述表结构的文件，名为：**表名.frm**。该文件是以二进制格式存储的。

### 表空间分类

- 系统表空间（system tablespace）：可以对应文件系统上一个或多个实际的文件，这些文件是自扩展文件。

在一个MySQL服务器中，**系统表空间只有一份**，表中的数据都会被默认存储到这个系统表空间（MySQL5.5.7到MySQL5.6.6）。默认情况下， InnoDB 会在数据目录下创建一个名为ibdata1 、大小为12M 的文件，这个文件就是对应的系统表空间在文件系统上的表示。

- 独立表空间（file-per-table tablespace）：

使用独立表空间来存储表数据，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，创建的表的表结构存在 `.frm` 文件中，每个表的数据和索引单独保存在`.ibd`文件中

- 其他表空间

除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、undo表空间（undo tablespace）、临时表空间（temporary tablespace）

- 系统表空间与独立表空间的转换

```sql
-- 修改启动参数`innodb_file_per_table` 控制
[server]
innodb_file_per_table=x

-- 把已经存在系统表空间中的表转移到独立表空间
ALTER TABLE 表名 TABLESPACE [=] innodb_file_per_table;
-- 把已经存在独立表空间的表转移到系统表空间
ALTER TABLE 表名 TABLESPACE [=] innodb_system;
```

------

------

# 索引

## 索引的概述

### 索引简介

MySQL 官方定义：索引（index）是帮助 MySQL 高效获取数据的一种数据结构，本质是排好序的快速查找数据结构。在表数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式指向数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。

**索引是在存储引擎层实现的**，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。对于InnoDB存储引擎，索引由上文介绍的数据页中的页目录与文件头部构成。

------

### 索引分类

- 功能分类
  - 单列索引：一个索引只包含单个列，一个表可以有多个单列索引（普通索引）
  - 联合索引：顾名思义，就是将单列索引进行组合
  - 唯一索引：索引列的值必须唯一，允许有空值。如果是联合索引，则列值组合必须唯一
  - 主键索引：一种特殊的唯一索引，不允许有空值，一般在建表时同时创建主键索引
  - 外键索引：只有 InnoDB 引擎支持外键索引，用来保证数据的一致性、完整性和实现级联操作
- 结构分类
  - BTree 索引：MySQL 使用最频繁的一个索引数据结构，是 InnoDB 和 MyISAM 存储引擎默认的索引类型，底层基于 B+Tree
  - Hash 索引：MySQL中 Memory 存储引擎默认支持的索引类型
  - R-tree 索引（空间索引）：空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型
  - Full-text 索引（全文索引）：快速匹配全部文档的方式。MyISAM 支持， InnoDB 不支持 FULLTEXT 类型的索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，MEMORY 引擎不支持

|   索引    |      InnoDB      | MyISAM | Memory |
| :-------: | :--------------: | :----: | :----: |
|   BTREE   |       支持       |  支持  |  支持  |
|   HASH    |      不支持      | 不支持 |  支持  |
|  R-tree   |      不支持      |  支持  | 不支持 |
| Full-text | 5.6 版本之后支持 |  支持  | 不支持 |

------

### 索引使用

索引在创建表的时候可以同时创建， 也可以随时增加新的索引

- 创建索引：如果一个表中有一列是主键，那么会**默认为其创建主键索引**（主键列不需要单独创建索引）

```sql
-- 索引类型默认是 B+TREE
CREATE [UNIQUE|FULLTEXT] INDEX 索引名称 [USING 索引类型] ON 表名(列名...);

-- 普通索引：为普通列创建的索引
CREATE INDEX 索引名称 [USING 索引类型] ON 表名(列名);

-- 唯一索引
CREATE UNIQUE INDEX 索引名称 [USING 索引类型] ON 表名(列名);

-- 全文索引
CREATE FULLTEXT INDEX 索引名称 [USING 索引类型] ON 表名(列名);

-- 联合索引
CREATE INDEX 索引名称 [USING 索引类型] ON 表名(列名1,列名2, ... ,列名n);
```

- 查看索引

```sql
SHOW INDEX FROM 表名;
```

- 添加索引

```sql
-- 普通索引
ALTER TABLE 表名 ADD INDEX 索引名称(列名);

-- 组合索引
ALTER TABLE 表名 ADD INDEX 索引名称(列名1,列名2,...);

-- 主键索引
ALTER TABLE 表名 ADD PRIMARY KEY(主键列名); 

-- 外键索引(添加外键约束，就是外键索引)
ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名);

-- 唯一索引
ALTER TABLE 表名 ADD UNIQUE 索引名称(列名);

-- 全文索引(mysql只支持文本类型)
ALTER TABLE 表名 ADD FULLTEXT 索引名称(列名);
```

- 删除索引

```sql
DROP INDEX 索引名称 ON 表名;
```

------

## 聚簇索引与非聚簇索引

### 索引对比

聚簇索引是一种数据存储方式，并不是一种单独的索引类型

- 聚簇索引的叶子节点存放的是主键值和数据行，支持覆盖索引
- 非聚簇索引的叶子节点存放的是主键值或指向数据行的指针（由存储引擎决定）

在 Innodb 下主键索引是聚簇索引，在 MyISAM 下主键索引是非聚簇索引

------

### InnoDB

#### 聚簇索引

在 Innodb 存储引擎，B+ 树索引可以分为聚簇索引（也称聚集索引、clustered index）和辅助索引（也称非聚簇索引或二级索引、secondary index、non-clustered index）

InnoDB 中，聚簇索引是按照每张表的主键构造一颗 B+ 树，叶子节点中存放的就是整张表的数据，将聚簇索引的叶子节点称为数据页

- 这个特性决定了**数据也是索引的一部分**，所以一张表只能有一个聚簇索引
- 辅助索引的存在不影响聚簇索引中数据的组织，所以一张表可以有多个辅助索引

聚簇索引的优点：

- 数据访问更快，聚簇索引将索引和数据保存在同一个 B+ 树中，因此从聚簇索引中获取数据比非聚簇索引更快
- 聚簇索引对于主键的排序查找和范围查找速度非常快

聚簇索引的缺点：

- 插入速度严重依赖于插入顺序，按照主键的顺序（递增）插入是最快的方式，否则将会出现页分裂，严重影响性能，所以对于 InnoDB 表，一般都会定义一个自增的 ID 列为主键
- 更新主键的代价很高，将会导致被更新的行移动，所以对于 InnoDB 表，一般定义主键为不可更新
- 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据

#### 辅助索引

在聚簇索引之上创建的索引称之为辅助索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引等

辅助索引叶子节点存储的是主键值，而不是数据的物理地址，所以访问数据需要二次查找，推荐使用覆盖索引，可以减少回表查询

检索过程：辅助索引找到主键值，再通过聚簇索引（二分）找到数据页，最后通过数据页中的 Page Directory（二分）找到对应的数据分组，遍历组内所所有的数据找到数据行

补充：无索引走全表查询，查到数据页后和上述步骤一致

#### 索引实现

InnoDB 使用 B+Tree 作为索引结构，并且 InnoDB 一定有索引

##### 主键索引

- 在 InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，这个索引的 key 是数据表的主键，叶子节点 data 域保存了完整的数据记录
- InnoDB 的表数据文件**通过主键聚集数据**，如果没有定义主键，会选择非空唯一索引代替，如果也没有这样的列，MySQL 会自动为 InnoDB 表生成一个**隐含字段**作为主键，这个字段长度为 6 个字节，类型为长整形（MVCC 部分的笔记提及）

##### 辅助索引

- InnoDB 的所有辅助索引（二级索引）都引用主键作为 data 域
- InnoDB 表是基于聚簇索引建立的，因此 InnoDB 的索引能提供一种非常快速的主键查找性能。不过辅助索引也会包含主键列，所以不建议使用过长的字段作为主键，**过长的主索引会令辅助索引变得过大**

![img](https://camo.githubusercontent.com/693e639371a341ccca29101982bfee9255c66a8e74a704ed11e3e9ed666440d7/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f4d7953514c2d496e6e6f44422545382538312539412545372542302538372545352539322538432545382542452538352545352538412541392545372542342541322545352542432539352545372542422539332545362539452538342e706e67)

------

### MyISAM

#### 非聚簇

MyISAM 的主键索引使用的是非聚簇索引，索引文件和数据文件是分离的，**索引文件仅保存数据的地址**

- 主键索引 B+ 树的节点存储了主键，辅助键索引 B+ 树存储了辅助键，表数据存储在独立的地方，这两颗 B+ 树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别
- 由于索引树是独立的，通过辅助索引检索无需访问主键的索引树回表查询

![img](https://camo.githubusercontent.com/078f32ab7a3b7b499e0592ecf2ec74c314a9cf4dacdb20e085cfaefe29aa0277/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f4d7953514c2d2545382538312539412545372542302538372545372542342541322545352542432539352545352539322538432545382542452538352545352538412541392545372542342541322545352542432539352545362541332538302545392539342538312545362539352542302545362538442541452545352539422542452e6a7067)

#### 索引实现

MyISAM 的索引方式也叫做非聚集的，之所以这么称呼是为了与 InnoDB 的聚集索引区分

主键索引：MyISAM 引擎使用 B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址

辅助索引：MyISAM 中主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复

[![img](https://camo.githubusercontent.com/d682f40868e7155f02b8211e0614b535c7e0bfb16092c39d6210c2470c725ada/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f4d7953514c2d4d794953414d2545342542382542422545392539342541452545352539322538432545382542452538352545352538412541392545372542342541322545352542432539352545372542422539332545362539452538342e706e67)](https://camo.githubusercontent.com/d682f40868e7155f02b8211e0614b535c7e0bfb16092c39d6210c2470c725ada/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f4d7953514c2d4d794953414d2545342542382542422545392539342541452545352539322538432545382542452538352545352538412541392545372542342541322545352542432539352545372542422539332545362539452538342e706e67)

------

## 索引的结构

### B树

BTree 的索引类型是基于 B+Tree 树型数据结构的，B+Tree 又是 BTree 数据结构的变种，用在数据库和操作系统中的文件系统，特点是能够保持数据稳定有序

BTree 又叫多路平衡搜索树，一颗 m 叉的 BTree 特性如下：

- 树中每个节点最多包含 m 个孩子
- 除根节点与叶子节点外，每个节点至少有 [ceil(m/2)] 个孩子
- 若根节点不是叶子节点，则至少有两个孩子
- 所有的叶子节点都在同一层
- 每个非叶子节点由 n 个key与 n+1 个指针组成，其中 [ceil(m/2)-1] <= n <= m-1

5 叉树，key 的数量 `[ceil(m/2)-1]  <=  n <= m-1` 为 2 <= n <=4 ，当 n>4 时中间节点分裂到父节点，两边节点分裂

插入 C N G A H E K Q M F W L T Z D P R X Y S 数据的工作流程：

- 插入前4个字母 C N G A

  [![img](https://camo.githubusercontent.com/fb5604ac591fae4b83cbdf18fbb5b7e8b699fd2da477651c927a3c6ba15287d6/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f4d7953514c2d4254726565254535254237254135254534254244253943254536254235253831254537254138253842312e706e67)](https://camo.githubusercontent.com/fb5604ac591fae4b83cbdf18fbb5b7e8b699fd2da477651c927a3c6ba15287d6/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f4d7953514c2d4254726565254535254237254135254534254244253943254536254235253831254537254138253842312e706e67)

- 插入H，n>4，中间元素G字母向上分裂到新的节点

  [![img](https://camo.githubusercontent.com/d4f3261c6168972758df2a75f4a3878e732b45ce271e07892e845632b19b86e2/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f4d7953514c2d4254726565254535254237254135254534254244253943254536254235253831254537254138253842322e706e67)](https://camo.githubusercontent.com/d4f3261c6168972758df2a75f4a3878e732b45ce271e07892e845632b19b86e2/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f4d7953514c2d4254726565254535254237254135254534254244253943254536254235253831254537254138253842322e706e67)

- 插入E，K，Q不需要分裂

  [![img](https://camo.githubusercontent.com/bcdf8c7beba2e3f369d9500f12b3bdd2dbe9e7d6c85368a0214f3f742f873aab/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f4d7953514c2d4254726565254535254237254135254534254244253943254536254235253831254537254138253842332e706e67)](https://camo.githubusercontent.com/bcdf8c7beba2e3f369d9500f12b3bdd2dbe9e7d6c85368a0214f3f742f873aab/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f4d7953514c2d4254726565254535254237254135254534254244253943254536254235253831254537254138253842332e706e67)

- 插入M，中间元素M字母向上分裂到父节点G

  [![img](https://camo.githubusercontent.com/71f60481da9d82678c38c49f70d88204c16643d10e39009893c1b8c5ffde55cc/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f4d7953514c2d4254726565254535254237254135254534254244253943254536254235253831254537254138253842342e706e67)](https://camo.githubusercontent.com/71f60481da9d82678c38c49f70d88204c16643d10e39009893c1b8c5ffde55cc/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f4d7953514c2d4254726565254535254237254135254534254244253943254536254235253831254537254138253842342e706e67)

- 插入F，W，L，T 不需要分裂

  [![img](https://camo.githubusercontent.com/d74d7f3146036e461aeeaecf7bfbaf866ed3fb9cc7d419954f01abd8808d00eb/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f4d7953514c2d4254726565254535254237254135254534254244253943254536254235253831254537254138253842352e706e67)](https://camo.githubusercontent.com/d74d7f3146036e461aeeaecf7bfbaf866ed3fb9cc7d419954f01abd8808d00eb/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f4d7953514c2d4254726565254535254237254135254534254244253943254536254235253831254537254138253842352e706e67)

- 插入Z，中间元素T向上分裂到父节点中

[![img](https://camo.githubusercontent.com/0ce9e6a8941c3b6555088cf275df2de988024e169a975839322afdc514c7af55/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f4d7953514c2d4254726565254535254237254135254534254244253943254536254235253831254537254138253842362e706e67)](https://camo.githubusercontent.com/0ce9e6a8941c3b6555088cf275df2de988024e169a975839322afdc514c7af55/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f4d7953514c2d4254726565254535254237254135254534254244253943254536254235253831254537254138253842362e706e67)

- 插入D，中间元素D向上分裂到父节点中，然后插入P，R，X，Y不需要分裂

  [![img](https://camo.githubusercontent.com/8d217f9cf64f6b3e514fb875154066d5afc230b05f77dc2837a4b7a42bb83ec0/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f4d7953514c2d4254726565254535254237254135254534254244253943254536254235253831254537254138253842372e706e67)](https://camo.githubusercontent.com/8d217f9cf64f6b3e514fb875154066d5afc230b05f77dc2837a4b7a42bb83ec0/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f4d7953514c2d4254726565254535254237254135254534254244253943254536254235253831254537254138253842372e706e67)

- 最后插入S，NPQR节点n>5，中间节点Q向上分裂，但分裂后父节点DGMT的n>5，中间节点M向上分裂

[![img](https://camo.githubusercontent.com/5ed5aff0b743bd61bc2f293c8f3cc3d13a5d32884e52ae9c8c88d38787a9d7cd/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f4d7953514c2d4254726565254535254237254135254534254244253943254536254235253831254537254138253842382e706e67)](https://camo.githubusercontent.com/5ed5aff0b743bd61bc2f293c8f3cc3d13a5d32884e52ae9c8c88d38787a9d7cd/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f4d7953514c2d4254726565254535254237254135254534254244253943254536254235253831254537254138253842382e706e67)

B 树就已经构建完成了，**BTree 树和二叉树相比， BTree 的层级结构比二叉树小，查询数据的效率更快**。

B树 结构的数据可以让系统高效的找到数据所在的磁盘块，定义一条记录为一个二元组 [key, data] ，key 为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key 值互不相同，B树 中的每个节点根据实际情况可以包含大量的关键字信息和分支 [![img](https://camo.githubusercontent.com/e3a0ad55f46fe036a6915b1d1c8bfb0bc965d7bcaac36810f9074503e328cfb2/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f2545372542342541322545352542432539352545372539412538342545352538452539462545372539302538362d42547265652e706e67)](https://camo.githubusercontent.com/e3a0ad55f46fe036a6915b1d1c8bfb0bc965d7bcaac36810f9074503e328cfb2/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f2545372542342541322545352542432539352545372539412538342545352538452539462545372539302538362d42547265652e706e67)

缺点：当进行范围查找时会出现回旋查找

------

### B+树

#### 数据结构

BTree 数据结构中每个节点中不仅包含数据的 key 值，还有 data 值。磁盘中每一页的存储空间是有限的，如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小，当存储的数据量很大时同样会导致 BTree 的深度较大，增大查询时的磁盘 I/O 次数，进而影响查询效率，所以引入 B+Tree

B+Tree 为 BTree 的变种，B+Tree 与 BTree 的区别为：

- n 叉 B+Tree 最多含有 n 个 key（哈希值），而 BTree 最多含有 n-1 个 key

- 所有**非叶子节点只存储键值 key** 信息，只进行数据索引，使每个非叶子节点所能保存的关键字大大增加
- 所有**数据都存储在叶子节点**，所以每次数据查询的次数都一样
- **叶子节点按照 key 大小顺序排列，左边结尾数据都会保存右边节点开始数据的指针，形成一个链表**
- 所有节点中的 key 在叶子节点中也存在（比如 5)，key 允许重复，B 树不同节点不存在重复的 key

![](E:\A_java\图像git\68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f4d7953514c2d422b54726565e695b0e68daee7bb93e69e842e706e67.png)

B* 树：是 B+ 树的变体，在 B+ 树的非根和非叶子结点再增加指向兄弟的指针

#### 优化结构

MySQL 索引数据结构对经典的 B+Tree 进行了优化，在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，**提高区间访问的性能，防止回旋查找**

区间访问的意思是访问索引为 5 - 15 的数据，可以直接根据相邻节点的指针遍历

B+ 树的叶子节点是数据页（page），一个页里面可以存多个数据行

[![img](https://camo.githubusercontent.com/998e12eb33b8d03558b3d67b867e59b95f29727086e51243d0a997725696bcbc/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f2545372542342541322545352542432539352545372539412538342545352538452539462545372539302538362d422b547265652e706e67)](https://camo.githubusercontent.com/998e12eb33b8d03558b3d67b867e59b95f29727086e51243d0a997725696bcbc/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f2545372542342541322545352542432539352545372539412538342545352538452539462545372539302538362d422b547265652e706e67)

通常在 B+Tree 上有两个头指针，**一个指向根节点，另一个指向关键字最小的叶子节点**，而且所有叶子节点（即数据节点）之间是一种链式环结构。可以对 B+Tree 进行两种查找运算：

- 有范围：对于主键的范围查找和分页查找
- 有顺序：从根节点开始，进行随机查找，顺序查找

InnoDB 中每个数据页的大小默认是 16KB，一般表的主键类型为 INT（4 字节）或 BIGINT（8 字节），指针类型也一般为 4 或 8 个字节，也就是说一个页（B+Tree 中的**一个节点**）中大概存储 16KB / (8B+8B)=1K 个键值（估值）。则一个深度为 3 的 B+Tree 索引可以维护 `10^3 * 10^3 * 10^3 = 10亿` 条记录

实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在 2-4 层。MySQL 的 InnoDB 存储引擎在设计时是**将根节点常驻内存的**，也就是说查找某一键值的行记录时最多只需要 1~3 次磁盘 I/O 操作

B+Tree 优点：提高查询速度，减少磁盘的 IO 次数，树形结构较小

#### 索引维护

B+ 树为了保持索引的有序性，在插入新值的时候需要做相应的维护

每个索引中每个块存储在磁盘页中，可能会出现以下两种情况：

- 如果所在的数据页已经满了，这时候需要申请一个新的数据页，然后挪动部分数据过去，这个过程称为**页分裂**
- 当相邻两个页由于删除了数据，利用率很低之后，会将数据页做**页合并**，合并的过程可以认为是分裂过程的逆过程
- 这两个情况都是由 B+ 树的结构决定的

一般选用数据小的字段做索引，字段长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小

------

### B+树底层实现

InnoDB存储引擎采用的B+树结构的索引。

InnoDB 数据页的7个组成部分，各个**数据页**通过文件头部的**FIL_PAGE_PREV**与**FIL_PAGE_NEXT**属性组成一个**双向链表**，而每个**数据页中的记录**会按照**主键值（记录头信息里的next_record属性）**从小到大的顺序组成一个**单向链表**，每个数据页都会为存储在它里边儿的记录生成一个**页目录**。在通过主键查找某条记录的时候，可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。

#### B+树索引的底层构造

建立索引要求：

- 下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值；

- 给所有的页建立一个目录项。这个目录项，称为索引。

16KB 的页在物理存储上不一定连续，从这么多页中根据主键值快速定位某些记录所在的页，需要给它们做个目录，每个页对应一个目录项。

每个目录项包括：

- 页的用户记录中最小的主键值，用key 来表示；
- 页号，用page_no 表示。

> 举例：
>
> ![image-20210927133511933](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210927133511933.png)
>
> 单个数据页：
>
> ![image-20210927094843195](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210927094843195.png)

这里的页30与下面的页10、28等数据页不同，页30里面装的是**目录项记录**，下面的页装的是**用户记录**。而且页30的一条记录里只包括：页的**用户记录中最小的主键值**和**页号**。

区分用户记录与目录项记录：通过记录头信息里的 record_type 属性，0 代表普通的用户记录，1 代表目录项记录，2 代表最小记录，3代表最大记录。

目录项记录与普通用户记录的不同点：

- 目录项记录的record_type 值是1，而普通用户记录的record_type 值是0；
- 目录项记录只有**主键值**和**页**的编号两个列，而普通的用户记录的列包括额外的记录的额外信息（根据定义的行格式确定）与记录的真实数据（隐藏列+真实数据）；
- 记录头信息中的min_rec_mask 属性，只有在存储目录项记录的页中的主键值最小的目录项记录的min_rec_mask 值为1 ，其他别的记录的min_rec_mask 值都是0 。

当数据更多，一个目录项装不下的时候，就需要更高级的目录项。

![image-20210927145704182](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210927145704182.png)

这样的数据结构，简化一下：

<img src="C:\Users\Administrator\Desktop\新建文件夹\b+++.webp" style="zoom:50%;" />

注意，图中同一层是双向链表，**最底层只有最下面那一层是双向链表**。这时候，如果倒立着看这张图，就很像一棵树。可以看出，**一个数据页代表树中的一个节点**。图中，最上面的代表数据范围更广的目录项记录数据页，称为根。中间的目录项记录数据页称为非叶子节点。而最底层的用户记录数据页，是真正存放数据的数据页，称为叶子节点。这样存储数据的结构，称为**B+树**。规定，最底层（存放用户记录的那层）为第0层。

------

## 索引设计原则

索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率

创建索引时的原则：

- 对查询频次较高，且数据量比较大的表建立索引
- 使用唯一索引，区分度越高，使用索引的效率越高
- 索引字段的选择，最佳候选列应当从 where 子句的条件中提取，使用覆盖索引
- 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的 I/O 效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升 MySQL 访问索引的 I/O 效率
- 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价越高。对于插入、更新、删除等 DML 操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低 DML 操作的效率，增加相应操作的时间消耗；另外索引过多的话，MySQL 也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但提高了选择的代价

- MySQL 建立**联合索引**时会遵守**最左前缀匹配原则**，即最左优先，在检索数据时从联合索引的最左边开始匹配

- 哪些情况不要建立索引：
  - 记录太少的表
  - 经常增删改的表
  - 频繁更新的字段不适合创建索引
  - where 条件里用不到的字段不创建索引

------

## 索引优化

### 覆盖索引

覆盖索引：包含所有满足查询需要的数据的索引（SELECT 后面的字段刚好是索引字段），可以利用该索引返回 SELECT 列表的字段，而不必根据索引去聚簇索引上读取数据文件

回表查询：要查找的字段不在非主键索引树上时，需要通过叶子节点的主键值去主键索引上获取对应的行数据

使用覆盖索引，防止回表查询。

> 举个例子：
>
> 表 user 主键为 id，普通索引为 age，查询语句：
>
> ```sql
> SELECT * FROM user WHERE age = 30;
> ```
>
> 查询过程：先通过普通索引 age=30 定位到主键值 id=1，再通过聚集索引 id=1 定位到行记录数据，需要两次扫描 B+ 树
>
> 使用覆盖索引：
>
> ```sql
> DROP INDEX idx_age ON user;
> CREATE INDEX idx_age_name ON user(age,name);
> SELECT id,age FROM user WHERE age = 30;
> ```
>
> 在一棵索引树上就能获取查询所需的数据，无需回表速度更快

使用覆盖索引，要注意 SELECT 列表中只取出需要的列，不可用 `SELECT *`，所有字段一起做索引会导致索引文件过大，查询性能下降

### 索引下推

索引条件下推优化（Index Condition Pushdown）是 MySQL5.6 添加，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数

索引下推充分利用了索引中的数据，在查询出整行数据之前过滤掉无效的数据，再去主键索引树上查找

- 不使用索引下推优化时存储引擎通过索引检索到数据返回给 MySQL 服务器，服务器判断数据是否符合条件，符合条件的数据去聚簇索引回表查询，获取完整的数据

![img](https://camo.githubusercontent.com/8b26ea34adc7fcab74fcf559a7ca331a2a83a858c7a512f410ec6ae3c9dae0dc/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f4d7953514c2d2545342542382538442545342542442542462545372539342541382545372542342541322545352542432539352545342542382538422545362538452541382e706e67)

- 使用索引下推优化时，如果**存在某些对索引的列的判断条件**时，MySQL 服务器将这一部分判断条件传递给存储引擎，由存储引擎在索引遍历的过程中判断数据是否符合传递的条件，将符合条件的数据进行回表，检索出来返回给服务器，由此减少 IO 次数

![img](https://camo.githubusercontent.com/6d30f42d7458ed8b3ef51577dbe68eb50f6f438205c3dd3f900123b1212c5c0f/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f44422f4d7953514c2d2545342542442542462545372539342541382545372542342541322545352542432539352545342542382538422545362538452541382e706e67)

**适用条件**：

- 需要存储引擎将索引中的数据与条件进行判断（所以条件列必须都在同一个索引中），所以优化是基于存储引擎的，只有特定引擎可以使用，适用于 InnoDB 和 MyISAM
- 存储引擎没有调用跨存储引擎的能力，跨存储引擎的功能有存储过程、触发器、视图，所以调用这些功能的不可以进行索引下推优化
- 对于 InnoDB 引擎只适用于二级索引，InnoDB 的聚簇索引会将整行数据读到缓冲区，不再需要去回表查询了，索引下推的目的减少 IO 次数也就失去了意义

> 举例：
>
> 用户表 user，(name, age) 是联合索引
>
> ```sql
> SELECT * FROM user WHERE name LIKE '张%' AND　age = 10;	-- 头部模糊匹配会造成索引失效
> ```
>
> - 优化前：在非主键索引树上找到满足第一个条件的行，然后通过叶子节点记录的主键值再回到主键索引树上查找到对应的行数据，再对比 AND 后的条件是否符合，符合返回数据，需要 4 次回表
>
> <img src="C:\Users\Administrator\Desktop\新建文件夹\tuitui.jpg" style="zoom:50%;" />
>
> -  优化后：检查索引中存储的列信息是否符合索引条件，然后交由存储引擎用剩余的判断条件判断此行数据是否符合要求，**只有满足条件的才会去读取表中的数据**，满足下推条件的就根据主键值进行回表查询，2 次回表
>
> <img src="C:\Users\Administrator\Desktop\新建文件夹\tuituitui.jpg" style="zoom: 50%;" />

当使用 EXPLAIN 进行分析时，如果使用了索引条件下推，Extra 会显示 Using index condition

### 前缀索引

当要索引的列字符很多时，索引会变大变慢，可以**只索引列开始的部分字符串**，节约索引空间，提高索引效率

注意：使用前缀索引就系统就忽略覆盖索引对查询性能的优化了

优化原则：降低重复的索引值

使用场景：存储身份证

- 直接创建完整索引，这样可能比较占用空间
- 创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引
- 倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题（前 6 位相同的很多）
- 创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描

### 索引合并

使用多个索引来完成一次查询的执行方法叫做索引合并 index merge

- Intersection 索引合并：

  ```sql
  -- key1 和 key3 列都是单列索引、二级索引
  SELECT * FROM table_test WHERE key1 = 'a' AND key3 = 'b'; 
  ```

  从不同索引中扫描到的记录的 id 值取**交集**（相同 id），然后执行回表操作，要求从每个二级索引获取到的记录都是按照主键值排序

- Union 索引合并：

  ```sql
  SELECT * FROM table_test WHERE key1 = 'a' OR key3 = 'b';
  ```

  从不同索引中扫描到的记录的 id 值取**并集**，然后执行回表操作，要求从每个二级索引获取到的记录都是按照主键值排序

- Sort-Union 索引合并

  ```sql
  SELECT * FROM table_test WHERE key1 < 'a' OR key3 > 'b';
  ```

  先将从不同索引中扫描到的记录的主键值进行排序，再按照 Union 索引合并的方式进行查询

### 最左前缀原则

最左前缀法则：当不匹配前面的字段的时候，后面的字段都是无序的。在检索数据时从联合索引的最左边开始匹配

```sql
-- 创建联合索引
create index idx_a_b_c on table1(a,b,c);
-- sql语句有没有命中索引
select * from table1 where a = 10;  -- 命中a
select * from table1 where a = 10 and b=20; -- 命中 (a,b)
select * from table1 where a = 10 and b=20 and c=30; -- 命中 (a,b,c)
select * from table1 where b = 10; -- 未命中
select * from table1 where b = 10 and c=30; -- 未命中
select * from table1 where a = 10 and c=30; -- 只命中a
select * from table1 where c = 30;-- 未命中
select * from table1 where c = 30 and a = 10 and b = 20; -- 命中(a,b,c) ——>>  mysql有一个内部优化器 会做一次内部优化。
```

- 联合索引设计原则：

频繁查找列置于最左边：需要频繁的**查找**某一列的数据，在设计联合索引的时候，需要将该索引列放到最左边；

较少维护：如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的；

考虑空间：采取(a,b)、(b) 还是 (b,a)、(a)这种格式呢？ 如：有两个字段，若name 字段是比 age 字段大的 ，那建议创建一个（name,age) 的联合索引和一个 (age) 的单字段索引。

- 最左前缀原则失效：**(a, b)，b索引能使用，是在a确定的情况下**！！

最左前缀原则，遇到范围查询时，范围查询的索引列后的索引列会失效。

最左前缀原则，遇到模糊查询时，类似like aa%这种后模糊查询索引可能会有效，like %aa模糊查询索引会无效。

------

## 索引失效

联合索引失效原因：[索引失效原理，终于有人讲明白了 - 云+社区 - 腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1704743)

模：模糊查询LIKE以%开头。a%可以使用索引，前缀法制。

型：数据类型错误

数：对索引字段使用内部函数

空：索引列为NULL

运：索引列四则运算

最：复合索引不安索引列最左开始查找

快：数据量小，全表扫描比索引列快

范：范围查询

字：索引列为字符类型，没有加 ''

------

## 避免索引失效

- 全值（等值）匹配 ，对索引中所有列都指定具体值

- 最左前缀法则

> 如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。具体参考上文。

- 范围查询右边的列，不能使用索引 
- 不要在索引列上进行运算操作， 索引将失效
- 字符串不加单引号，造成索引失效

> 由于，在查询时，没有对字符串加单引号，MySQL的查询优化器，会自动的进行类型转换，造成索引失效。

- 尽量使用覆盖索引，避免`select *`

> 尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select * 。
>
> 但是查询列有索引列里面不包括的列，也会降低性能。

- 用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到

> ```sql
> -- name字段是索引列 ， 而createtime不是索引列，中间是or进行连接是不走索引的 ：
> explain select * from tb_seller where name='黑马程序员' or createtime = '2088-01-01 12:00:00'\G;	
> ```
>

-  以%开头的Like模糊查询，索引失效

> 如果仅仅是尾部模糊匹配（`'牛逼%`'），索引不会失效。如果是头部模糊匹配（`'%牛逼'`），索引失效。

- 如果MySQL评估使用索引比全表更慢，则不使用索引
- is  NULL ， is NOT NULL  有时索引失效
- in 走索引， not in 索引失效，因为not in是一个范围查询
- 尽量使用复合索引，而少使用单列索引 ，因为复合索引相当于创建了好几个索引

```sql
TIP : 
	
    using index ：使用覆盖索引的时候就会出现

    using where：在查找使用索引的情况下，需要回表去查询所需的数据

    using index condition：查找使用了索引，但是需要回表查询数据

    using index ; using where：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据
```

------

## 查看索引的使用

```sql
show status like 'Handler_read%';	

show global status like 'Handler_read%';
```

![image-20211115164532160](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211115164532160.png)

- Handler_read_first：索引中第一条被读的次数。如果较高，表示服务器正执行大量全索引扫描（这个值越低越好）。

- Handler_read_key：如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）。

- Handler_read_next ：按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。
- Handler_read_prev：按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY ... DESC。
- Handler_read_rnd ：根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救。
- Handler_read_rnd_next：在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。

------

------

